<template>
  <div class="gauges-container">
    <canvas ref="gaugeOEE" width="250" height="200"></canvas>
  </div>
</template>

<script>
export default {
  data() {
    return {
      max: 100,
      gauges: {
        OEE: {
          currentValue: 0,
          targetValue: 0,
          label: 'OEE',
          textColor: '#000',
          arrowColor: '#000',
          zones: [
            { start: 0, end: 60, color: '#e94f4f' }, // red
            { start: 60, end: 75, color: '#f2ca44' }, // yellow
            { start: 75, end: 100, color: '#4acf4a' } // green
          ]
        }
      }
    }
  },
  mounted() {
    // Get canvas contexts
    this.ctx = {
      OEE: this.$refs.gaugeOEE.getContext('2d') // this.$ref.<refName>.getContext('2d') <refName> needs to be the same as the refName up in the <template></template> section
    }

    // Listen for Node-RED messages
    this.$socket.on('msg-input:' + this.id, (msg) => {
      if (msg.payload) {
        Object.keys(this.gauges).forEach(g => {
          if (msg.payload[g] != null) {
            this.gauges[g].targetValue = Math.min(Math.max(msg.payload[g], 0), this.max)
            this.animateArrow(g)
          }
        })
      }
    })

    // Draw initial gauges
    Object.keys(this.gauges).forEach(g => this.drawGauge(g, 0))
  },
  methods: {
    animateArrow(gauge) {
      const step = () => {
        const g = this.gauges[gauge]
        g.currentValue += (g.targetValue - g.currentValue) * 0.1
        this.drawGauge(gauge, g.currentValue)
        if (Math.abs(g.currentValue - g.targetValue) > 0.5) {
          requestAnimationFrame(step)
        }
      }
      requestAnimationFrame(step)
    },

    drawGauge(gauge, value) {
      const g = this.gauges[gauge]
      const ctx = this.ctx[gauge]
      const width = ctx.canvas.width
      const height = ctx.canvas.height
      ctx.clearRect(0, 0, width, height)

      const centerX = width / 2
      const centerY = height - 40
      const outerRadius = 100
      const arcWidth = 12
      const arrowWidth = 18

      // Draw colored zones
      g.zones.forEach(zone => {
        const startAngle = Math.PI + (zone.start / this.max) * Math.PI
        const endAngle = Math.PI + (zone.end / this.max) * Math.PI
        ctx.beginPath()
        ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle, false)
        ctx.lineWidth = arcWidth
        ctx.strokeStyle = zone.color
        ctx.lineCap = 'round'
        ctx.stroke()
      })

      // Draw arrow on outer edge
      const angle = Math.PI + (value / this.max) * Math.PI
      const tipX = centerX + outerRadius * Math.cos(angle)
      const tipY = centerY + outerRadius * Math.sin(angle)
      const baseRadius = outerRadius - arcWidth - 3
      const baseX = centerX + baseRadius * Math.cos(angle)
      const baseY = centerY + baseRadius * Math.sin(angle)
      const perpX = (arrowWidth / 2) * Math.cos(angle + Math.PI / 2)
      const perpY = (arrowWidth / 2) * Math.sin(angle + Math.PI / 2)

      ctx.beginPath()
      ctx.moveTo(tipX, tipY)
      ctx.lineTo(baseX + perpX, baseY + perpY)
      ctx.lineTo(baseX - perpX, baseY - perpY)
      ctx.closePath()
      ctx.fillStyle = g.arrowColor
      ctx.fill()

      // Draw label above gauge
      ctx.fillStyle = g.textColor
      ctx.font = '16px Arial'
      ctx.textAlign = 'center'
      ctx.fillText(g.label, centerX, centerY - outerRadius - 20)

      // Draw numeric value
      ctx.font = 'bold 34px Arial'
      ctx.fillText(value.toFixed(2), centerX, centerY - 40)

      // Draw % symbol
      ctx.font = '20px Arial'
      ctx.fillText('%', centerX, centerY - 20)
    }
  }
}
</script>

<style scoped>
.gauges-container {
  display: flex;
  justify-content: center;
  gap: 30px;
}
canvas {
  display: block;
  background: transparent;
}
</style>
